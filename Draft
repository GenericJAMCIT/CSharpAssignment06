Test Topic 1
Python is a high-level yet easy to learn, due in part to its high readability, third generation programming language that was introduced in 1991 by its creator Guido van Rossum. It is used by many large companies for web development and there are some distinct advantages that give it an edge. Python comes with a large library of prewritten code for everything from simple expressions to CGI and image manipulation. When utilized this can boost a programmer’s productivity by virtue of writing less code. Python also is a hybrid of procedural and object-oriented programming patterns. This is all included in an open source and free package making for an affordable option.
C++ is another general purpose third generation programming language and is an extension of C created by Bjarne Stroustrup in 1985. Now featuring functionality as a multi-paradigm programming language utilizing object oriented, imperative, and generic patterns. C++ gives the user complete control over memory allocation. Instead of using the Garbage Collector methodology, periodically using wasted memory, it uses pointers. Pointers are like coordinates for specific memory locations. C++ being closely related to C is not only compatible with C but also allows for low level data manipulation due to its relation to machine language.
Structures Query Language (SQL) is a fourth generation programming language designed for relational data stream management systems (RDSMS) developed at IBM by Donald Chamberlin and Raymond Boyce. As a 4GL it is an extra abstraction from machine code as in closer to human language along with being a declarative language. Being declarative means your code often describes how you want to process information in plain English. SQL features different ways to manipulate information you access from databases such as restricting, comparing, and joining. SQL also incorporates functions that are familiar in other languages like stored procedures, exception handling, and loop variations. Since SQL only makes requests to the RDSMS to either display or change there is no storing of records client-side.
 Clarion is one of the first fourth generation programming languages, developed in the 1980s, which makes the proprietary language significant historically. Its primary purpose is to create database applications. It sits beneath the commercial Clarion integrated development environment (IDE) and works as an extra abstraction from machine language, similar to how Netbeans utilizes JAVA or Visual Studio uses Window Forms in congress with C#, the developer pieces together forms to create templates. There have been a lot of templates created over the years by developers and are either sold or exist open source. Clarion is also compatible with many other data manipulation languages like SQL and RDSMS software like Oracle.

Test Topic 2
My strategy for tackling large scale applications is to understand the larger picture whilst keeping my development load relatively small. Reading through the requirements multiple times to get a solid grasp on what the client wants from the application before any sort of architectural planning. If I were working for a client or directly under a superior, I would convene with them to understand the minute details. Getting feedback early and often can save you a lot of headache down the line. Now even though I would have a thorough outline my architectural planning would be comparatively loosely formed. I believe attempting to plan out every little detail is a fool’s errand because often during development your application will evolve. I find this especially true when working on assignments for CIT as my application may change drastically based on new techniques I acquire during development. Once I have a loose framework but solid outline, I parcel out the processes into small undertakings with the purpose of not getting overwhelmed by the large project. I operate under the ideology that you can only development a program one line at a time. This includes debugging and testing. I tend to test often, sometimes each line of new code, and I tackle bugs as they appear. Bugs can interact with each other in a multiplying effect so fixing ten bugs is ten times worse than fixing a single bug. When I get stuck on a particularly difficult issue, I try to leave my ego at the door and ask for help. Coding has been around for a long time and some languages for decades. This says to me that there are experienced people who have already encountered and solved the same issues I am experiencing. If you try to tackle an issue alone, you might end up spending hours on a process that someone has already solved. The coding community seems genuinely willing to help and that is why I am not afraid to ask for it. Lastly, I double check my final application. Countless times have I thought my application was perfect only to find small, dumb yet destructive mistakes.

Test Topic 3
Binary Search Tree is a data structure that is defined by each parent node’s relation to a maximum of two children nodes referred to as the left child and right child. It’s important to understand that the difference between a Binary Tree and Binary Search Tree is that the right child is greater than, while the left node is lesser than, the root node which gives us a ‘balanced’ tree. The concept of restricting the number of related nodes gives us an easy way of traversal, insertion, sorting, and deletion. The structure of the Binary Search Tree is a single root node with an address to a left and right node, the same being true for those left and right nodes, respectively. In my code I have created a Binary Tree class with a single property of our root node which is of type node referencing our node class. In the Binary Tree class, I also have three functions that simply check if the root node is not null, verifying if the binary tree exists essentially, in my find, insert and traversal methods. For the insert method if the root is null it will create the first node. The node class contains three properties firstly for storing the data of each node, secondly storing the address of the right node, and thirdly storing the address of the left node. In my node class I have included three standard methods. Find method, passing in the value of a desired node and recursively compares it with the right and left nodes. Insert method, passing in the value of the new node and compares it to left or right nodes based on greater than or lesser than comparators to find its correct position. Traversal using in order method, recursively loops through left and right nodes printing them in numerical order. Finally, I instantiate the Binary Tree class as a global instance for the rest of my program to reference.






Test Topic 6
Creational, structural, and behavioural are the three types of design patterns in C# and I will explain the purpose of all three. Creational design patterns are patterns that manage the sometimes-complex mechanic in C# of object creation. For example, in assessment 4 I used the singleton design pattern, a pattern that has you create a single global instance of an object wherein all classes may reference, in my binary tree application. I created an instance of my main form which allowed for me to easily reference form-specific methods like printing to labels within nested classes. Structural design patterns define how classes and objects will inherit from each other to form the much larger program. Though the seven types of structural patterns will all help us conceptualize the structure of our program each type has a different purpose. The Adapter pattern can be used when two conflicting objects need to use an interface essentially converting it into a more useful interface. The Flyweight pattern stores objects to reduce both the number of objects needed along with minimizing memory usage. Behavioural design pattern relates to the way individual objects and classes communicate. Utilizing these patterns discerns communication processes, implements them, and allows for flexibility if you wanted to dictate a communication process. The Observer pattern is when a single object, our ‘observable object’, exists with a direct communication to dependant objects or our ‘observer objects’. When the observable object changes the observers are all updated simultaneously based on the response handlers we have set up. For example, an online shop may have an option to notify a customer when a specific item becomes available. When the observable object is updated with the additional item it sends out a communication to all the customer observers so that they are update simultaneously and our response handlers send out emails.
